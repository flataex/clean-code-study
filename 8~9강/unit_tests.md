# 9장 단위 테스트

과거에는 Test code를 안 짜거나 짜더라도 일회성으로 버리는 코드인 경우가 많았습니다. 요즘에는 TDD라는 개념도 생겨나고 테스트 코드의 중요성이 높아지고 있습니다.
간단하게 내용만 다뤘으며 테스트 코드라는 주제는 한 장으로 다루기에는 너무 방대하다고 합니다.

테스트 코드

- 유연성, 유지보수성, 재사용성이라는 장정이 있습니다.
- 테스트 코드 깨끗하게 관리해야합니다.
- 표현력을 높이고 간결하게 정리해야합니다.
- 테스트 API를 구현해 DSL을 만들면 테스트가 쉬워집니다.

## TDD 법칙 세 가지

- 첫째 법칙: 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
- 둘째 법칙: 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
- 셋째 법칙: 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

테스트 코드와 실제 코드가 함께 작성되며 테스트 코드가 실제 코드보다 불과 몇 초 전에 작성됩니다.
이렇게 진행하면 실제 코드를 사실상 전부 테스트하는 테스트 케이스가 나오는 것입니다. 하지만 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 합니다.

## 깨끗한 테스트 코드 유지하기

```
// test.spec.js --- 테스트 슈트
import { test, expect } from '@playwright/test';

test('has title', async ({ page }) => { // --- 테스트 유닛
  await page.goto('https://playwright.dev/');

  // Expect a title "to contain" a substring.
  await expect(page).toHaveTitle(/Playwright/); // --- 테스트 케이스
});
```

테스트 코드는 실제 코드만큼이나 정돈되고 깔끔하게 작성해야합니다. 실제 코드를 수정하여 테스트 코드를 수정해야할 떄 코드가 더럽다면
수정을 주저하게 되고 이는 테스트 슈트 자체를 버리는 길로 이어집니다. 코드를 수정할 때 누구나 두려움이 있습니다. 하지만 잘 짜여진 테스트 코드가 있다면 두려움이 줄어들겁니다.
물론 테스트 커버리지가 높을수록 더욱이 말입니다.

## 깨끗한 테스트 코드

꺠끗한 코드는 곧 가독성입니다.
가독성은 실제 코드보다 테스트 코드에서 더욱 중요하며 테스트 코드는 최소의 표현으로 많은 것을 나타내야 합니다.

## 이중 표준

테스트 API코드는 단순, 간결, 표현력이 풍부해야 하지만, 실제 코드만큼 효율적일 필요는 없습니다.
실제 환경이 아니라 테스트 환경에서 돌아가는 코드이기 때문입니다.

## 테스트 당 assert 하나

## 테스트당 개념 하나

"테스트 함수마다 한 개념만 테스트하라" 이것저것 잡다한 개념을 연속으로 테스트하는 긴 함수는 피해야 합니다.
한 함수로 몰아넣으면 독자가 각 절이 거기에 존재하는 이유와 각 절이 테스트하는 개념을 모두 이해해야 하기에 비용이 많이 듭니다.

## F.I.R.S.T

깨끗한 테스트는 다음 FIRST(다섯 가지 규칙)규칙이 있습니다.

- Fast 빠르게:
  테스트는 빨리 돌아야 합니다. 테스트가 느리면 자주 돌릴 엄두를 못 내고 초반에 문제를 찾아내 고치지 못하고
  코드를 마음껏 정리하지도 못합니다. 결국은 코드 품질이 떨어지는 길입니다.

- Independent 독립적으로:
  한 테스트가 다음 테스트가 실행될 환경을 준비해서는 안 되며 독립적으로 구동해야합니다. 테스트 유닛, 테스트 슈트 순서가 변경되어도 문제가 없어야합니다.
  의존성을 갖는 테스트 잇달아 실패하므로 원인을 진단하기 어려워지며 후반 테스트가 찾아내야 할 결함이 숨겨진다.

- Repeatable 반복가능하게:
  테스트는 어떤 환경에서도 반복 가능해야 합니다.
  실제 환경, QA 환경, 버스를 타고 집으로 가는 길에 사용하는 노트북 환경(네트워크가 연결되지 않은)에서도 실행할 수 있어야 합니다.
  테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생기며 환경이 지원되지 않기에 테스트를 수행하지 못하는 상황에 직면한다.

- Self-Validating 자가검증하는:
  테스트는 boolean 값으로 결과를 내며, 통과 여부를 알리고 로그 파일을 읽게 만들어서는 안 됩니다.
  통과 여부를 보려고 텍스트 파일 두 개를 수작업으로 비교하게 만들어서도 안 됩니다. (여의치 않는 상황이면 사용해야하지 않을까합니다.)
  테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적이 되며 지루한 수작업 평가가 필요하게 됩니다.

- Timely 적시에:
  단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현하며, 실제 코드를 구현한 다음에 테스트 코드를 만들면 실제 코드가 테스트하기 어렵다거나 불가능하도록 설계한 사실을 발견할지도 모릅니다.
