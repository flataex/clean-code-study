# 8장. 경게

시스템에 들어가는 모든 소프트웨어를 직접 개발하는 경우는 드물다. 때로는 패키지를 사고 때로는 오픈 소스를 이용한다. 이렇게 외부 코드를 통합하는 부분을 소프트웨어 경계라고 한다.

## 외부 코드 사용하기

패키지 제공자는 적용성을 최대한 넓히려 하고, 사용자는 자신의 요구에 집중하는 인터페이스를 바란다. 이런 긴장으로 인해 시스템 경계에서 문제가 생길 소지가 많다.

### 예시 : Map

- `Map`이 제공하는 기능성광 유연성은 확실히 유용하지만 그만큼 위험도 크다.
- 예를 들어, `Map`의 `clear()` 메서드는 `Map`의 사용자라면 누구나 `Map` 내용을 지울 권한이 있다. 혹은 설계시 `Map`에 특정 유형만 저장하기로 결정했지만 `Map`에서 객체 유형을 제한하지 않기 때문에 마음만 먹으면 사용자는 어떤 객체 유형도 추가할 수 있다.

```javascript
const map = new Map();
```

```javascript
map.get("auth");
```

위의 경우에서, `Map`이 반환하는 `Object`를 올바른 유형으로 변환할 책임은 `Map`을 사용하는 클라이언트에 있다.

이러한 경우 타입스크립트에서는 `Generic`을 사용한다.

```typescript
const map = new Map<string, Data>();

map.set("data", data);
```

그렇지만 위 방법도 사용자에게 필요하지 않은 기능까지 제공한다는 문제는 해결하지 못한다.

아래와 같이 사용하면 좀 더 깔끔해진다.

```typescript
class User {
  constructor() {
    this.data = new Map<string, Data>();
  }

  getById(id: string) {
    return this.data.get(id);
  }
}
```

경계 인터페이스인 `Map`을 `User` 클래스 안으로 숨긴다. 따라서 `Map` 인터페이스가 변하더라도 나머지 프로그램에는 영향을 미치지 않는다. 제네릭스를 사용하든 하지 않든 더이상 문제가 안 된다. `User` 클래스 안에서 객체 유형을 관리하고 변환하기 때문이다.

`Map` 클래스를 사용할 때마다 위와 같이 캡슐화하라는 소리가 아니다. `Map`을 여기저기 넘기지 말란 말이다. `Map`과 같은 경계 인터페이스를 사용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다. `Map` 인스턴스를 공개 API 인수로 넘기거나 반환값으로 사용하지 않는다.

## 경계 살피고 익히기

- 외부 패키지 테스트는 우리 책임이 아니지만 우리 자신을 위해 우리가 사용할 코드는 테스트하는 편이 바람직하다.

- 곧바로 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히면 어떨까? 짐 뉴커크는 이를 `학습 테스트`라고 부른다.

- 학습 테스트는 프로그램에서 사용하려는 방식대로 외부 API를 호출한다. 통제된 환경에서 API를 제대로 이해하는지를 확인하는 셈이다.

## 학습 테스트는 공짜 이상이다

- 학습 테스트에 드는 비용은 없다. 어쨌든 API를 배워야 하므로 오히려 필요한 지식만 확보하는 손쉬운 방법이다. 학습 테스트는 이해도를 높여주는 정확한 실험이다.
- 학습 테스트는 공짜 이상이다. 투자하는 노력보다 얻는 성과가 더 크다. 패키지 새 버전이 나온다면 학습 테스트를 돌려 차이가 있는지 확인한다.
- 학습 테스트는 패키지가 예상대로 도는지 검증한다. 일단 통합한 이후라고 하더라도 패키지가 우리 코드와 호환되리라는 보장은 없다. 패키지 작성자에게 코드를 변경할 필요가 생길지도 모른다. 패키지 작성자는 버그를 수정하고 기능도 추가한다. 패키지 새 버전이 나올 때마다 새로운 위험이 생긴다. 새 버전이 우리 코드와 호환되지 않으면 학습 테스트가 이 사실을 곧바로 밝혀낸다.
- 학습 테스트를 이용한 학습이 필요하든 그렇지 않든, 실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하다. 이런 경계 테스트가 있다면 패키지의 새 버전으로 이전하기 쉬워진다. 그렇지 않다면 낡은 버전을 필요 이상으로 오래 사용하려는 유횩에 빠지기 쉽다.

## 아직 존재하지 않는 코드를 사용하기

아는 코드와 모르는 코드를 분리하라

### 예시 : 무선통신 소프트웨어 개발

1.

- `송신기`라는 하위 시스템이 존재한다.
- 우리 팀은여기에 대한 지식이 없다.
- 타 팀에서 개발 예정이다.

2.

- 우리 팀이 `송신기` 모듈에게 원하는 기능을 정의한다.
- `송신기` API가 설계되지 않았으므로 구현을 나중으로 미룬다.

3.

- 이쪽 코드를 진행하고자 자체적으로 인터페이스를 정의하고 구현한다.
- 추후 `송신기` 모듈의 개발이 완료되어 `Adapter Pattern`을 이용하여 우리 코드와 결합하였다.

## 깨끗한 경계

- 경계에 위치하는 코드는 깔끔히 분리한다. 기대치를 정의하는 테스트 케이스도 작성한다.

- 통제 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 좋다.

- 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하는 것이 좋다.

- 새로운 클래스로 경계를 감싸거나, `Adapter Pattern`을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환한다.
