# 냄새와 휴리스틱

## 주석

1. 부적절한 정보

   작성자, 최종 수정 날짜, SPR 번호 등과 같은 메타 데이터만 표기합니다.

- SPR 문제 식별 리포트

2. 쓸모 없는 주석

   오래되고 부적절하며 부정확한 언급은 쓸모가 없습니다.

3. 중복된 주석

   주석은 코드가 스스로 말할 수 없는 것을 말해야 합니다. 코드로 가능한 설명은 중복됨으로 제거해야합니다.

4. 성의 없는 주석

5. 주석 처리된 코드

   형상관리 도구(github 등)이 있기에 과감히 지웁니다.

## 환경

1.  여러 단계로 빌드해야 한다.

    빌드는 한단계로 끝나야합니다.

    `npm run build-android`

    `cd android && ./gradlew clean && ./gradlew assembleRelease`

2.  여려 단계로 테스트해야한다.

    모든 단위 테스트는 한 명령으로 실행가능해야합니다.

## 기능

1.  너무 많은 인수

    함수에는 인수가 적을수록 좋습니다.

2.  출력 인수

    인수로 받은 값을 함수 내에서 수정하는 것은 직관적이지 않으므로 피해야합니다.

3.  플래그 인수

    SRP 위반

4.  죽은 함수

    호출되지 않은 함수는 지웁니다.

## 일반

1.  한 소스 파일에 여러 언어를 사용한다.

    소스 파일에 하나의 언어만 포함하는 것이 이상적입니다.
    (너무 이상적임)

2.  당연한 동작을 구현하지 않는다.

    "최소한의 놀라움의 원칙"에 따라 모든 함수 또는 클래스는 다른 프로그래머가 기대할 수 있는 동작을 구현해야 합니다. 그렇지 않으면 저자를 신뢰하지 못하게되어 코드를 일일이 살펴보게됩니다.

3.  경계를 올바로 처리하지 않는다.

    모든 경계 조건을 찾고 이에 대한 테스트를 작성하십시오.

4.  안전 절차 무시

    경고를 무시하고 개발을 한다는 것은 위험합니다.

5.  중복

6.  추상화 수준이 올바르지 못하다.

    저차원 추상화 상세개념과 고차원 추상화 일반 개념을 분리해야합니다.

7.  기초 클래스가 파생 클래스에 의존한다.

    기초 클래스(고차원 추상화)가 파생 클래스(저차원 추상화)에 의존하게되면 상세내용을 수정할 때마다 기초클래스 또한 수정해야합니다.

8.  과도한 정보

    클래스나 모듈에서 제공하는 함수는 적을수록 좋습니다.

9.  죽은 코드

죽은 코드는 실행되지 않는 코드입니다. 발생할 수 없는 조건을 확인하는 if 문의 본문에서 찾을 수 있습니다 . throw 하지 않는 try 의 catch 블록 에서 찾을 수 있습니다 . 호출되지 않는 작은 유틸리티 메서드나 발생하지 않는 스위치/케이스 조건 에서 찾을 수 있습니다 .

적절한 매장을 제공하십시오. 시스템에서 삭제하십시오.

10. 수직 분리

    변수와 함수는 사용되는 위치에 가깝게 정의되어야 합니다.

11. 불일치
    특정한 방식으로 구현한다면, 비슷한 함수를 작성할 때에도 같은 방식으로 작성해야합니다.(최소 놀람의 원칙)

12. 잡동사니

    사용되지 않는 변수, 호출되지 않는 함수, 정보를 추가하지 않는 주석 등은 지워줍니다.

13. 인위적 결합

    함수, 상수, 변수를 선언할 떄는 편한곳에 두지 않고 올바른 곳에 위치시킵니다.

    ex) 한곳에서만 사용한다는 이유로 함수에 넣어버린 enum

14. 기능 욕심

    다른 함수의 의존성을 가져서는 안됩니다.

15. 선택기 인수

    함수의 인수를 넣어 제어하려는 것은 옳지 못합니다.

16. 모호한 의도

    행을 바꾸지 않거나 헝가리식표기법(타입을 변수명 앞에서 작성함)은 의도를 모호하게 만듭니다.

17. 잘못 지운 책임

    함수의 이름을 통해 명확하게 무엇을 하는지 알 수 있게해야합니다.

18. 부적절한 static 함수

19. 서술적인 변수

    서술적인 변수를 사용하면 가독성이 높아집니다.

20. 이름과 기능이 일치하는 함수

    이름만 보고도 어떤 기능을하는 함수인지 알게끔 작성해야합니다.

21. 알고리즘 이해하라

    동작하는 알고리즘을 모른다면 함수가 지저분해지기 마련입니다. 어떤 알고리즘인지 알고 재구성하여 클린코드를 작성해야합니다.

22. 논리적 종속성을 물리적으로 만들기

    ??

23. If/Else 또는 Switch/Case보다 다형성을 사용하라

    If/Else 또는 switch 문을 대신하는 다형성 객체를 생성해야 합니다.

24. 표준 표기법을 따르라

25. 매직 숫자를 명명된 상수로 교체하라

    의미없는 상수까지 변수로 선언할 필요는 없다.

26. 정확해야 합니다.

    용도에 맞는 제약을 걸어서 정확성을 높여야합니다.

27. 관례보다 구조를 사용하라

    ??

28. 조건을 캡슐화하라

    조건을 변수나 함수로 분리하여야합니다.

29. 부정 조건은 피하라

    가능하면 조건문은 긍정적으로 표현해야 합니다.

30. 함수는 한 가지만 수행해야 한다.

31. 숨겨진 시간적인 결합

    순서가 중요한 코드에서는 순서를 강제하게 하는것이 좋습니다.

32. 일관성을 유지하라

33. 경계 조건 캡슐화

    경계조건을 한 곳에서 처리해야 오류를 막을 수 있습니다.

34. 함수는 추상화 수준을 한 단계만 내려가야 한다.

    ??

35. 설정 정보는 최상위 단계에 둬라

36. 추이적 탐색을 피하라

    A -> B -> C를 호출한다고 A -> C를 알 필요가 없다. 한 모듈이 주변 모듈을 모를수록 좋습니다.(결합도가 낮아짐)

## 자바

1.  긴 import 목록을 피하고 와일드카드를 사용하라

2.  상수는 상속하지 않는다

3.  상수 대 Enum

    상수보다 Enum을 사용하는것이 의미를 알기 좋습니다.

## 이름

1.  서술적인 이름을 사용하라

2.  적절한 추상화 수준에서 이름을 선택하라

3.  가능하다면 표준 명명법을 사용하라

4.  명확한 이름

5.  긴 범위는 긴 이름 사용하라

6.  인코딩 피하기

    m\_ 또는 f 와 같은 접두사는 오늘날의 환경에서 쓸모가 없습니다.

7.  이름으로 부수 효과를 설명하라

## 테스트

1.  불충분한 테스트

2.  커버리지 도구를 사용하라!

3.  사소한 테스트를 건너뛰지 마라

4.  무시된 테스트는 모호성 뜻한다

5.  경계 조건을 테스트하라

6.  버그 주변은 철저히 테스트하라

7.  테스트 커버리지 패턴을 살펴라

8.  테스트는 빨라야 한다

## 결론

이 장에서 나온것들을 전부 적용한다고 클린 코드가 되지 않습니다. 다만 기준으로 잡고 접근한다면 클린 코드가 나올 수 있습니다.
